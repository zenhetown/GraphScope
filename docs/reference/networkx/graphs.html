

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Graph types &mdash; GraphScope  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="graphscope.experimental.nx.Graph.__init__" href="generated/graphscope.experimental.nx.Graph.__init__.html" />
    <link rel="prev" title="NetworkX-style API(Preview)" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> GraphScope
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../deployment.html">Deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../loading_graph.html">Loading Graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../interactive_engine.html">GraphScope Interactive Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../analytics_engine.html">GraphScope Analytical Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../learning_engine.html">GraphScope Learning Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer_guide.html">Developer Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../python_index.html">Python API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../session.html">Session</a></li>
<li class="toctree-l2"><a class="reference internal" href="../graph.html">Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../app.html">Analytical App</a></li>
<li class="toctree-l2"><a class="reference internal" href="../context.html">Context</a></li>
<li class="toctree-l2"><a class="reference internal" href="../selector.html">Selector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../operation.html">Operation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cython_sdk.html">Cython SDK API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interactive.html">Interactive Query</a></li>
<li class="toctree-l2"><a class="reference internal" href="../learning.html">Graph Learning</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">NetworkX-style API(Preview)</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Graph types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#graph">Graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="#digraph">DiGraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="#edge-list">Edge List</a></li>
<li class="toctree-l4"><a class="reference internal" href="#adjacency-list">Adjacency List</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="builtin.html">Builtin algorithms</a></li>
<li class="toctree-l3"><a class="reference internal" href="functions.html">Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="generators.html">Graph generators</a></li>
<li class="toctree-l3"><a class="reference internal" href="convert.html">Converting to and from other data formats</a></li>
<li class="toctree-l3"><a class="reference internal" href="relabel.html">Relabeling nodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="io.html">Reading and writing graphs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../analytical_engine_index.html">Analytical Engine API Reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GraphScope</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../python_index.html">Python API Reference</a> &raquo;</li>
        
          <li><a href="index.html">NetworkX-style API(Preview)</a> &raquo;</li>
        
      <li>Graph types</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/reference/networkx/graphs.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="graph-types">
<span id="graphs"></span><h1>Graph types<a class="headerlink" href="#graph-types" title="Permalink to this headline">¶</a></h1>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 17%" />
<col style="width: 28%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Class</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Self-loops allowed</p></th>
<th class="head"><p>Parallel edges allowed</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Graph</p></td>
<td><p>undirected</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>DiGraph</p></td>
<td><p>directed</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
</tbody>
</table>
<div class="section" id="graph">
<h2>Graph<a class="headerlink" href="#graph" title="Permalink to this headline">¶</a></h2>
<p>Undirected graphs with self loops</p>
<dl class="py class">
<dt id="graphscope.experimental.nx.Graph">
<em class="property">class </em><code class="sig-prename descclassname">graphscope.experimental.nx.</code><code class="sig-name descname">Graph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incoming_graph_data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/graphscope/experimental/nx/classes/graph.html#Graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graphscope.experimental.nx.Graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for undirected graphs.</p>
<p>A Graph stores nodes and edges with optional data, or attributes.</p>
<p>Graphs hold undirected edges. Self loops are allowed but multiple
(parallel) edges are not.</p>
<p>Nodes can be strings or integers objects with optional key/value attributes.</p>
<p>Edges are represented as links between nodes with optional
key/value attributes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incoming_graph_data</strong> (<em>input graph</em><em> (</em><em>optional</em><em>, </em><em>default: None</em><em>)</em>) – Data to initialize graph. If None (default) an empty
graph is created.  The data can be any format that is supported
by the to_nx_graph() function, currently including edge list,
dict of dicts, dict of lists, NetworkX graph, NumPy matrix
or 2d ndarray, SciPy sparse matrix, or a graphscope graph.</p></li>
<li><p><strong>attr</strong> (<em>keyword arguments</em><em>, </em><em>optional</em><em> (</em><em>default= no attributes</em><em>)</em>) – Attributes to add to graph as key=value pairs.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#graphscope.experimental.nx.DiGraph" title="graphscope.experimental.nx.DiGraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">graphscope.Graph</span></code></p>
</div>
<p class="rubric">Examples</p>
<p>Create an empty graph structure (a “null graph”) with no nodes and
no edges.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
</pre></div>
</div>
<p>G can be grown in several ways.</p>
<p><strong>Nodes:</strong></p>
<p>Add one node at a time:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Add the nodes from any container (a list, dict, set or
even the lines from a file or the nodes from another graph).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">110</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition integers, strings can represent a node.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;a node&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Edges:</strong></p>
<p>G can also be grown by adding edges.</p>
<p>Add one edge,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>a list of edges,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
</pre></div>
</div>
<p>or a collection of edges,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
</pre></div>
</div>
<p>If some edges connect nodes not yet in the graph, the nodes
are added automatically.  There are no errors when adding
nodes or edges that already exist.</p>
<p><strong>Attributes:</strong></p>
<p>Each graph, node, and edge can hold key/value attribute pairs
in an associated attribute dictionary (the keys must be string).
By default these are empty, but can be added or changed using
add_edge, add_node or direct manipulation of the attribute
dictionaries named graph, node and edge respectively.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">day</span><span class="o">=</span><span class="s2">&quot;Friday&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">graph</span>
<span class="go">{&#39;day&#39;: &#39;Friday&#39;}</span>
</pre></div>
</div>
<p>Add node attributes using add_node(), add_nodes_from() or G.nodes</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="s1">&#39;5pm&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="s1">&#39;2pm&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">{&#39;time&#39;: &#39;5pm&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;room&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">714</span>  <span class="c1"># node must exist already to use G.nodes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;room&#39;</span><span class="p">]</span>  <span class="c1"># remove attribute</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(1, {&#39;time&#39;: &#39;5pm&#39;}), (3, {&#39;time&#39;: &#39;2pm&#39;})]</span>
</pre></div>
</div>
<p>Add edge attributes using add_edge(), add_edges_from(), subscript
notation, or G.edges.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">4.7</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;blue&#39;</span><span class="p">}),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">})])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>
</div>
<p>Warning: we protect the graph data structure by making <cite>G.edges</cite> a
read-only dict-like structure. However, you can assign to attributes
in e.g. <cite>G.edges[1, 2]</cite>. Thus, use 2 sets of brackets to add/change
data attributes: <cite>G.edges[1, 2][‘weight’] = 4</cite></p>
<p><strong>Shortcuts:</strong></p>
<p>Many common graph features allow python syntax to speed reporting.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="ow">in</span> <span class="n">G</span>     <span class="c1"># check if node in graph</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1"># iterate through nodes</span>
<span class="go">[1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>  <span class="c1"># number of nodes in graph</span>
<span class="go">5</span>
</pre></div>
</div>
<p>Often the best way to traverse all edges of a graph is via the neighbors.
The neighbors are reported as an adjacency-dict <cite>G.adj</cite> or <cite>G.adjacency()</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">nbrsdict</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adjacency</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">nbr</span><span class="p">,</span> <span class="n">eattr</span> <span class="ow">in</span> <span class="n">nbrsdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">... </span>       <span class="k">if</span> <span class="s1">&#39;weight&#39;</span> <span class="ow">in</span> <span class="n">eattr</span><span class="p">:</span>
<span class="gp">... </span>           <span class="c1"># Do something useful with the edges</span>
<span class="gp">... </span>           <span class="k">pass</span>
</pre></div>
</div>
<p>But the edges() method is often more convenient:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;weight&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>        <span class="c1"># Do something useful with the edges</span>
<span class="gp">... </span>        <span class="k">pass</span>
</pre></div>
</div>
<p><strong>Reporting:</strong></p>
<p>Simple graph information is obtained using object-attributes and methods.
Reporting typically provides views instead of containers to reduce memory
usage. The views update as the graph is updated similarly to dict-views.
The objects <cite>nodes, `edges</cite> and <cite>adj</cite> provide access to data attributes
via lookup (e.g. <cite>nodes[n], `edges[u, v]</cite>, <cite>adj[u][v]</cite>) and iteration
(e.g. <cite>nodes.items()</cite>, <cite>nodes.data(‘color’)</cite>,
<cite>nodes.data(‘color’, default=’blue’)</cite> and similarly for <cite>edges</cite>)
Views exist for <cite>nodes</cite>, <cite>edges</cite>, <cite>neighbors()</cite>/<cite>adj</cite> and <cite>degree</cite>.</p>
<p>For details on these and other miscellaneous methods, see below.</p>
</dd></dl>

<p>Adding and removing nodes and edges</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.__init__.html#graphscope.experimental.nx.Graph.__init__" title="graphscope.experimental.nx.Graph.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.__init__</span></code></a>([incoming_graph_data])</p></td>
<td><p>Initialize a graph with edges, name, or graph attributes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.add_node.html#graphscope.experimental.nx.Graph.add_node" title="graphscope.experimental.nx.Graph.add_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.add_node</span></code></a>(node_for_adding, **attr)</p></td>
<td><p>Add a single node <cite>node_for_adding</cite> and update node attributes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.add_nodes_from.html#graphscope.experimental.nx.Graph.add_nodes_from" title="graphscope.experimental.nx.Graph.add_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.add_nodes_from</span></code></a>(nodes_for_adding, **attr)</p></td>
<td><p>Add multiple nodes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.remove_node.html#graphscope.experimental.nx.Graph.remove_node" title="graphscope.experimental.nx.Graph.remove_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.remove_node</span></code></a>(n)</p></td>
<td><p>Remove node n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.remove_nodes_from.html#graphscope.experimental.nx.Graph.remove_nodes_from" title="graphscope.experimental.nx.Graph.remove_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.remove_nodes_from</span></code></a>(nodes_for_removing)</p></td>
<td><p>Remove multiple nodes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.add_edge.html#graphscope.experimental.nx.Graph.add_edge" title="graphscope.experimental.nx.Graph.add_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.add_edge</span></code></a>(u_of_edge, v_of_edge, **attr)</p></td>
<td><p>Add an edge between u and v.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.add_edges_from.html#graphscope.experimental.nx.Graph.add_edges_from" title="graphscope.experimental.nx.Graph.add_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.add_edges_from</span></code></a>(ebunch_to_add, **attr)</p></td>
<td><p>Add all the edges in ebunch_to_add</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.add_weighted_edges_from.html#graphscope.experimental.nx.Graph.add_weighted_edges_from" title="graphscope.experimental.nx.Graph.add_weighted_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.add_weighted_edges_from</span></code></a>(ebunch_to_add)</p></td>
<td><p>Add weighted edges in <cite>ebunch_to_add</cite> with specified weight attr</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.remove_edge.html#graphscope.experimental.nx.Graph.remove_edge" title="graphscope.experimental.nx.Graph.remove_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.remove_edge</span></code></a>(u, v)</p></td>
<td><p>Remove the edge between u and v.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.remove_edges_from.html#graphscope.experimental.nx.Graph.remove_edges_from" title="graphscope.experimental.nx.Graph.remove_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.remove_edges_from</span></code></a>(ebunch)</p></td>
<td><p>Remove all edges specified in ebunch.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.update.html#graphscope.experimental.nx.Graph.update" title="graphscope.experimental.nx.Graph.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.update</span></code></a>([edges, nodes])</p></td>
<td><p>Update the graph using nodes/edges/graphs as input.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.clear.html#graphscope.experimental.nx.Graph.clear" title="graphscope.experimental.nx.Graph.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.clear</span></code></a>()</p></td>
<td><p>Remove all nodes and edges from the graph.</p></td>
</tr>
</tbody>
</table>
<p>Reporting nodes edges and neighbors</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.nodes.html#graphscope.experimental.nx.Graph.nodes" title="graphscope.experimental.nx.Graph.nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.nodes</span></code></a></p></td>
<td><p>A NodeView of the Graph as G.nodes or G.nodes().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.__iter__.html#graphscope.experimental.nx.Graph.__iter__" title="graphscope.experimental.nx.Graph.__iter__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.__iter__</span></code></a>()</p></td>
<td><p>Iterate over the nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.has_node.html#graphscope.experimental.nx.Graph.has_node" title="graphscope.experimental.nx.Graph.has_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.has_node</span></code></a>(n)</p></td>
<td><p>Returns True if the graph contains the node n.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.get_node_data.html#graphscope.experimental.nx.Graph.get_node_data" title="graphscope.experimental.nx.Graph.get_node_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.get_node_data</span></code></a>(**kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.__contains__.html#graphscope.experimental.nx.Graph.__contains__" title="graphscope.experimental.nx.Graph.__contains__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.__contains__</span></code></a>(n)</p></td>
<td><p>Returns True if n is a node, False otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.edges.html#graphscope.experimental.nx.Graph.edges" title="graphscope.experimental.nx.Graph.edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.edges</span></code></a></p></td>
<td><p>An EdgesView of the Graph as G.edges or G.edges().</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.has_edge.html#graphscope.experimental.nx.Graph.has_edge" title="graphscope.experimental.nx.Graph.has_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.has_edge</span></code></a>(u, v)</p></td>
<td><p>Returns True if the edge (u, v) is in the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.get_edge_data.html#graphscope.experimental.nx.Graph.get_edge_data" title="graphscope.experimental.nx.Graph.get_edge_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.get_edge_data</span></code></a>(u, v[, default])</p></td>
<td><p>Returns the attribute dictionary associated with edge (u, v).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.neighbors.html#graphscope.experimental.nx.Graph.neighbors" title="graphscope.experimental.nx.Graph.neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.neighbors</span></code></a>(n)</p></td>
<td><p>Returns an iterator over all neighbors of node n.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.adj.html#graphscope.experimental.nx.Graph.adj" title="graphscope.experimental.nx.Graph.adj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.adj</span></code></a></p></td>
<td><p>Graph adjacency object holding the neighbors of each node.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.__getitem__.html#graphscope.experimental.nx.Graph.__getitem__" title="graphscope.experimental.nx.Graph.__getitem__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.__getitem__</span></code></a>(n)</p></td>
<td><p>Return a dict of neighbors of node n.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.adjacency.html#graphscope.experimental.nx.Graph.adjacency" title="graphscope.experimental.nx.Graph.adjacency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.adjacency</span></code></a>()</p></td>
<td><p>Returns an iterator over (node, adjacency dict) tuples for all nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.nbunch_iter.html#graphscope.experimental.nx.Graph.nbunch_iter" title="graphscope.experimental.nx.Graph.nbunch_iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.nbunch_iter</span></code></a>([nbunch])</p></td>
<td><p>Returns an iterator over nodes contained in nbunch that are also in the graph.</p></td>
</tr>
</tbody>
</table>
<p>Counting nodes edges and neighbors</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.order.html#graphscope.experimental.nx.Graph.order" title="graphscope.experimental.nx.Graph.order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.order</span></code></a>()</p></td>
<td><p>Returns the number of nodes in the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.number_of_nodes.html#graphscope.experimental.nx.Graph.number_of_nodes" title="graphscope.experimental.nx.Graph.number_of_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.number_of_nodes</span></code></a>()</p></td>
<td><p>Returns the number of nodes in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.__len__.html#graphscope.experimental.nx.Graph.__len__" title="graphscope.experimental.nx.Graph.__len__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.__len__</span></code></a>()</p></td>
<td><p>Returns the number of nodes in the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.degree.html#graphscope.experimental.nx.Graph.degree" title="graphscope.experimental.nx.Graph.degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.degree</span></code></a></p></td>
<td><p>A DegreeView for the Graph as G.degree or G.degree().</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.size.html#graphscope.experimental.nx.Graph.size" title="graphscope.experimental.nx.Graph.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.size</span></code></a>([weight])</p></td>
<td><p>Returns the number of edges or total of all edge weights.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.number_of_edges.html#graphscope.experimental.nx.Graph.number_of_edges" title="graphscope.experimental.nx.Graph.number_of_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.number_of_edges</span></code></a>([u, v])</p></td>
<td><p>Returns the number of edges between two nodes.</p></td>
</tr>
</tbody>
</table>
<p>Making copies and subgraphs</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.copy.html#graphscope.experimental.nx.Graph.copy" title="graphscope.experimental.nx.Graph.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.copy</span></code></a>([as_view])</p></td>
<td><p>Returns a copy of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.to_undirected.html#graphscope.experimental.nx.Graph.to_undirected" title="graphscope.experimental.nx.Graph.to_undirected"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.to_undirected</span></code></a>([as_view])</p></td>
<td><p>Returns an undirected copy of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.to_directed.html#graphscope.experimental.nx.Graph.to_directed" title="graphscope.experimental.nx.Graph.to_directed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.to_directed</span></code></a>([as_view])</p></td>
<td><p>Returns a directed representation of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.subgraph.html#graphscope.experimental.nx.Graph.subgraph" title="graphscope.experimental.nx.Graph.subgraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.subgraph</span></code></a>(nodes)</p></td>
<td><p>Returns a SubGraph view of the subgraph induced on <cite>nodes</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.Graph.edge_subgraph.html#graphscope.experimental.nx.Graph.edge_subgraph" title="graphscope.experimental.nx.Graph.edge_subgraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.edge_subgraph</span></code></a>(edges)</p></td>
<td><p>Returns the subgraph induced by the specified edges.</p></td>
</tr>
</tbody>
</table>
<p>Project simple graph</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#graphscope.experimental.nx.Graph.project_to_simple" title="graphscope.experimental.nx.Graph.project_to_simple"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.project_to_simple</span></code></a>([v_prop, e_prop])</p></td>
<td><p>Project nx graph to a simple graph to run builtin alogorithms.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="digraph">
<h2>DiGraph<a class="headerlink" href="#digraph" title="Permalink to this headline">¶</a></h2>
<p>Directed graphs with self loops</p>
<dl class="py class">
<dt id="graphscope.experimental.nx.DiGraph">
<em class="property">class </em><code class="sig-prename descclassname">graphscope.experimental.nx.</code><code class="sig-name descname">DiGraph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incoming_graph_data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/graphscope/experimental/nx/classes/digraph.html#DiGraph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graphscope.experimental.nx.DiGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for directed graphs.</p>
<p>A DiGraph stores nodes and edges with optional data, or attributes.</p>
<p>DiGraphs hold directed edges.  Self loops are allowed but multiple
(parallel) edges are not.</p>
<p>Nodes can be strings or integers objects with optional key/value attributes.</p>
<p>Edges are represented as links between nodes with optional
key/value attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incoming_graph_data</strong> (<em>input graph</em><em> (</em><em>optional</em><em>, </em><em>default: None</em><em>)</em>) – Data to initialize graph. If None (default) an empty
graph is created.  The data can be any format that is supported
by the to_networkx_graph() function, currently including edge list,
dict of dicts, dict of lists, NetworkX graph, NumPy matrix
or 2d ndarray, SciPy sparse matrix, or a graphscope graph.</p></li>
<li><p><strong>attr</strong> (<em>keyword arguments</em><em>, </em><em>optional</em><em> (</em><em>default= no attributes</em><em>)</em>) – Attributes to add to graph as key=value pairs.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#graphscope.experimental.nx.Graph" title="graphscope.experimental.nx.Graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">graphscope.Graph</span></code></p>
</div>
<p class="rubric">Examples</p>
<p>Create an empty graph structure (a “null graph”) with no nodes and
no edges.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
</pre></div>
</div>
<p>G can be grown in several ways.</p>
<p><strong>Nodes:</strong></p>
<p>Add one node at a time:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Add the nodes from any container (a list, dict, set or
even the lines from a file or the nodes from another graph).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">110</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition integers, strings can represent a node.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;a node&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Edges:</strong></p>
<p>G can also be grown by adding edges.</p>
<p>Add one edge,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>a list of edges,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
</pre></div>
</div>
<p>or a collection of edges,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
</pre></div>
</div>
<p>If some edges connect nodes not yet in the graph, the nodes
are added automatically.  There are no errors when adding
nodes or edges that already exist.</p>
<p><strong>Attributes:</strong></p>
<p>Each graph, node, and edge can hold key/value attribute pairs
in an associated attribute dictionary (the keys must be hashable).
By default these are empty, but can be added or changed using
add_edge, add_node or direct manipulation of the attribute
dictionaries named graph, node and edge respectively.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">day</span><span class="o">=</span><span class="s2">&quot;Friday&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">graph</span>
<span class="go">{&#39;day&#39;: &#39;Friday&#39;}</span>
</pre></div>
</div>
<p>Add node attributes using add_node(), add_nodes_from() or G.nodes</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="s1">&#39;5pm&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="s1">&#39;2pm&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">{&#39;time&#39;: &#39;5pm&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;room&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">714</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;room&#39;</span><span class="p">]</span> <span class="c1"># remove attribute</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(1, {&#39;time&#39;: &#39;5pm&#39;}), (3, {&#39;time&#39;: &#39;2pm&#39;})]</span>
</pre></div>
</div>
<p>Add edge attributes using add_edge(), add_edges_from(), subscript
notation, or G.edges.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">4.7</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;blue&#39;</span><span class="p">}),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">8</span><span class="p">})])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>
</div>
<p>Warning: we protect the graph data structure by making <cite>G.edges[1, 2]</cite> a
read-only dict-like structure. However, you can assign to attributes
in e.g. <cite>G.edges[1, 2]</cite>. Thus, use 2 sets of brackets to add/change
data attributes: <cite>G.edges[1, 2][‘weight’] = 4</cite>
(For multigraphs: <cite>MG.edges[u, v, key][name] = value</cite>).</p>
<p><strong>Shortcuts:</strong></p>
<p>Many common graph features allow python syntax to speed reporting.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="ow">in</span> <span class="n">G</span>     <span class="c1"># check if node in graph</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1"># iterate through nodes</span>
<span class="go">[1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>  <span class="c1"># number of nodes in graph</span>
<span class="go">5</span>
</pre></div>
</div>
<p>Often the best way to traverse all edges of a graph is via the neighbors.
The neighbors are reported as an adjacency-dict <cite>G.adj</cite> or <cite>G.adjacency()</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">nbrsdict</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adjacency</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">nbr</span><span class="p">,</span> <span class="n">eattr</span> <span class="ow">in</span> <span class="n">nbrsdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">... </span>       <span class="k">if</span> <span class="s1">&#39;weight&#39;</span> <span class="ow">in</span> <span class="n">eattr</span><span class="p">:</span>
<span class="gp">... </span>           <span class="c1"># Do something useful with the edges</span>
<span class="gp">... </span>           <span class="k">pass</span>
</pre></div>
</div>
<p>But the edges reporting object is often more convenient:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>        <span class="c1"># Do something useful with the edges</span>
<span class="gp">... </span>        <span class="k">pass</span>
</pre></div>
</div>
<p><strong>Reporting:</strong></p>
<p>Simple graph information is obtained using object-attributes and methods.
Reporting usually provides views instead of containers to reduce memory
usage. The views update as the graph is updated similarly to dict-views.
The objects <cite>nodes, `edges</cite> and <cite>adj</cite> provide access to data attributes
via lookup (e.g. <cite>nodes[n], `edges[u, v]</cite>, <cite>adj[u][v]</cite>) and iteration
(e.g. <cite>nodes.items()</cite>, <cite>nodes.data(‘color’)</cite>,
<cite>nodes.data(‘color’, default=’blue’)</cite> and similarly for <cite>edges</cite>)
Views exist for <cite>nodes</cite>, <cite>edges</cite>, <cite>neighbors()</cite>/<cite>adj</cite> and <cite>degree</cite>.</p>
<p>For details on these and other miscellaneous methods, see below.</p>
</dd></dl>

<p>Adding and removing nodes and edges</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.__init__.html#graphscope.experimental.nx.DiGraph.__init__" title="graphscope.experimental.nx.DiGraph.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.__init__</span></code></a>([incoming_graph_data])</p></td>
<td><p>Initialize a graph with edges, name, or graph attributes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.add_node.html#graphscope.experimental.nx.DiGraph.add_node" title="graphscope.experimental.nx.DiGraph.add_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.add_node</span></code></a>(node_for_adding, **attr)</p></td>
<td><p>Add a single node <cite>node_for_adding</cite> and update node attributes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.add_nodes_from.html#graphscope.experimental.nx.DiGraph.add_nodes_from" title="graphscope.experimental.nx.DiGraph.add_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.add_nodes_from</span></code></a>(nodes_for_adding, **attr)</p></td>
<td><p>Add multiple nodes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.remove_node.html#graphscope.experimental.nx.DiGraph.remove_node" title="graphscope.experimental.nx.DiGraph.remove_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.remove_node</span></code></a>(n)</p></td>
<td><p>Remove node n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.remove_nodes_from.html#graphscope.experimental.nx.DiGraph.remove_nodes_from" title="graphscope.experimental.nx.DiGraph.remove_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.remove_nodes_from</span></code></a>(nodes_for_removing)</p></td>
<td><p>Remove multiple nodes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.add_edge.html#graphscope.experimental.nx.DiGraph.add_edge" title="graphscope.experimental.nx.DiGraph.add_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.add_edge</span></code></a>(u_of_edge, v_of_edge, **attr)</p></td>
<td><p>Add an edge between u and v.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.add_edges_from.html#graphscope.experimental.nx.DiGraph.add_edges_from" title="graphscope.experimental.nx.DiGraph.add_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.add_edges_from</span></code></a>(ebunch_to_add, **attr)</p></td>
<td><p>Add all the edges in ebunch_to_add</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.add_weighted_edges_from.html#graphscope.experimental.nx.DiGraph.add_weighted_edges_from" title="graphscope.experimental.nx.DiGraph.add_weighted_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.add_weighted_edges_from</span></code></a>(ebunch_to_add)</p></td>
<td><p>Add weighted edges in <cite>ebunch_to_add</cite> with specified weight attr</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.remove_edge.html#graphscope.experimental.nx.DiGraph.remove_edge" title="graphscope.experimental.nx.DiGraph.remove_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.remove_edge</span></code></a>(u, v)</p></td>
<td><p>Remove the edge between u and v.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.remove_edges_from.html#graphscope.experimental.nx.DiGraph.remove_edges_from" title="graphscope.experimental.nx.DiGraph.remove_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.remove_edges_from</span></code></a>(ebunch)</p></td>
<td><p>Remove all edges specified in ebunch.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.update.html#graphscope.experimental.nx.DiGraph.update" title="graphscope.experimental.nx.DiGraph.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.update</span></code></a>([edges, nodes])</p></td>
<td><p>Update the graph using nodes/edges/graphs as input.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.clear.html#graphscope.experimental.nx.DiGraph.clear" title="graphscope.experimental.nx.DiGraph.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.clear</span></code></a>()</p></td>
<td><p>Remove all nodes and edges from the graph.</p></td>
</tr>
</tbody>
</table>
<p>Reporting nodes edges and neighbors</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.nodes.html#graphscope.experimental.nx.DiGraph.nodes" title="graphscope.experimental.nx.DiGraph.nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.nodes</span></code></a></p></td>
<td><p>A NodeView of the Graph as G.nodes or G.nodes().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.__iter__.html#graphscope.experimental.nx.DiGraph.__iter__" title="graphscope.experimental.nx.DiGraph.__iter__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.__iter__</span></code></a>()</p></td>
<td><p>Iterate over the nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.has_node.html#graphscope.experimental.nx.DiGraph.has_node" title="graphscope.experimental.nx.DiGraph.has_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.has_node</span></code></a>(n)</p></td>
<td><p>Returns True if the graph contains the node n.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.__contains__.html#graphscope.experimental.nx.DiGraph.__contains__" title="graphscope.experimental.nx.DiGraph.__contains__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.__contains__</span></code></a>(n)</p></td>
<td><p>Returns True if n is a node, False otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.edges.html#graphscope.experimental.nx.DiGraph.edges" title="graphscope.experimental.nx.DiGraph.edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.edges</span></code></a></p></td>
<td><p>An OutEdgeView of the DiGraph as G.edges or G.edges().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.out_edges.html#graphscope.experimental.nx.DiGraph.out_edges" title="graphscope.experimental.nx.DiGraph.out_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.out_edges</span></code></a></p></td>
<td><p>An OutEdgeView of the DiGraph as G.edges or G.edges().</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.in_edges.html#graphscope.experimental.nx.DiGraph.in_edges" title="graphscope.experimental.nx.DiGraph.in_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.in_edges</span></code></a></p></td>
<td><p>An InEdgeView of the Graph as G.in_edges or G.in_edges().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.has_edge.html#graphscope.experimental.nx.DiGraph.has_edge" title="graphscope.experimental.nx.DiGraph.has_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.has_edge</span></code></a>(u, v)</p></td>
<td><p>Returns True if the edge (u, v) is in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.get_edge_data.html#graphscope.experimental.nx.DiGraph.get_edge_data" title="graphscope.experimental.nx.DiGraph.get_edge_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.get_edge_data</span></code></a>(u, v[, default])</p></td>
<td><p>Returns the attribute dictionary associated with edge (u, v).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.neighbors.html#graphscope.experimental.nx.DiGraph.neighbors" title="graphscope.experimental.nx.DiGraph.neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.neighbors</span></code></a>(n)</p></td>
<td><p>Returns an iterator over successor nodes of n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.adj.html#graphscope.experimental.nx.DiGraph.adj" title="graphscope.experimental.nx.DiGraph.adj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.adj</span></code></a></p></td>
<td><p>Graph adjacency object holding the successors of each node.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.__getitem__.html#graphscope.experimental.nx.DiGraph.__getitem__" title="graphscope.experimental.nx.DiGraph.__getitem__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.__getitem__</span></code></a>(n)</p></td>
<td><p>Return a dict of neighbors of node n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.successors.html#graphscope.experimental.nx.DiGraph.successors" title="graphscope.experimental.nx.DiGraph.successors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.successors</span></code></a>(n)</p></td>
<td><p>Returns an iterator over successor nodes of n.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.succ.html#graphscope.experimental.nx.DiGraph.succ" title="graphscope.experimental.nx.DiGraph.succ"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.succ</span></code></a></p></td>
<td><p>Graph adjacency object holding the successors of each node.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.predecessors.html#graphscope.experimental.nx.DiGraph.predecessors" title="graphscope.experimental.nx.DiGraph.predecessors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.predecessors</span></code></a>(n)</p></td>
<td><p>Returns an iterator over predecessor nodes of n.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.pred.html#graphscope.experimental.nx.DiGraph.pred" title="graphscope.experimental.nx.DiGraph.pred"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.pred</span></code></a></p></td>
<td><p>Graph adjacency object holding the predecessors of each node.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.adjacency.html#graphscope.experimental.nx.DiGraph.adjacency" title="graphscope.experimental.nx.DiGraph.adjacency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.adjacency</span></code></a>()</p></td>
<td><p>Returns an iterator over (node, adjacency dict) tuples for all nodes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.nbunch_iter.html#graphscope.experimental.nx.DiGraph.nbunch_iter" title="graphscope.experimental.nx.DiGraph.nbunch_iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.nbunch_iter</span></code></a>([nbunch])</p></td>
<td><p>Returns an iterator over nodes contained in nbunch that are also in the graph.</p></td>
</tr>
</tbody>
</table>
<p>Counting nodes edges and neighbors</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.order.html#graphscope.experimental.nx.DiGraph.order" title="graphscope.experimental.nx.DiGraph.order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.order</span></code></a>()</p></td>
<td><p>Returns the number of nodes in the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.number_of_nodes.html#graphscope.experimental.nx.DiGraph.number_of_nodes" title="graphscope.experimental.nx.DiGraph.number_of_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.number_of_nodes</span></code></a>()</p></td>
<td><p>Returns the number of nodes in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.__len__.html#graphscope.experimental.nx.DiGraph.__len__" title="graphscope.experimental.nx.DiGraph.__len__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.__len__</span></code></a>()</p></td>
<td><p>Returns the number of nodes in the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.degree.html#graphscope.experimental.nx.DiGraph.degree" title="graphscope.experimental.nx.DiGraph.degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.degree</span></code></a></p></td>
<td><p>A DegreeView for the Graph as G.degree or G.degree().</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.in_degree.html#graphscope.experimental.nx.DiGraph.in_degree" title="graphscope.experimental.nx.DiGraph.in_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.in_degree</span></code></a></p></td>
<td><p>An InDegreeView for (node, in_degree) or in_degree for single node.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.out_degree.html#graphscope.experimental.nx.DiGraph.out_degree" title="graphscope.experimental.nx.DiGraph.out_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.out_degree</span></code></a></p></td>
<td><p>An OutDegreeView for (node, out_degree)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.size.html#graphscope.experimental.nx.DiGraph.size" title="graphscope.experimental.nx.DiGraph.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.size</span></code></a>([weight])</p></td>
<td><p>Returns the number of edges or total of all edge weights.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.number_of_edges.html#graphscope.experimental.nx.DiGraph.number_of_edges" title="graphscope.experimental.nx.DiGraph.number_of_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.number_of_edges</span></code></a>([u, v])</p></td>
<td><p>Returns the number of edges between two nodes.</p></td>
</tr>
</tbody>
</table>
<p>Making copies and subgraphs</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.copy.html#graphscope.experimental.nx.DiGraph.copy" title="graphscope.experimental.nx.DiGraph.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.copy</span></code></a>([as_view])</p></td>
<td><p>Returns a copy of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.to_undirected.html#graphscope.experimental.nx.DiGraph.to_undirected" title="graphscope.experimental.nx.DiGraph.to_undirected"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.to_undirected</span></code></a>([as_view])</p></td>
<td><p>Returns an undirected copy of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.to_directed.html#graphscope.experimental.nx.DiGraph.to_directed" title="graphscope.experimental.nx.DiGraph.to_directed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.to_directed</span></code></a>([as_view])</p></td>
<td><p>Returns a directed representation of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.subgraph.html#graphscope.experimental.nx.DiGraph.subgraph" title="graphscope.experimental.nx.DiGraph.subgraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.subgraph</span></code></a>(nodes)</p></td>
<td><p>Returns a SubGraph view of the subgraph induced on <cite>nodes</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.edge_subgraph.html#graphscope.experimental.nx.DiGraph.edge_subgraph" title="graphscope.experimental.nx.DiGraph.edge_subgraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.edge_subgraph</span></code></a>(edges)</p></td>
<td><p>Returns the subgraph induced by the specified edges.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.reverse.html#graphscope.experimental.nx.DiGraph.reverse" title="graphscope.experimental.nx.DiGraph.reverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.reverse</span></code></a>([copy])</p></td>
<td><p>Returns the reverse of the graph.</p></td>
</tr>
</tbody>
</table>
<p>Project simple graph</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/graphscope.experimental.nx.DiGraph.project_to_simple.html#graphscope.experimental.nx.DiGraph.project_to_simple" title="graphscope.experimental.nx.DiGraph.project_to_simple"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiGraph.project_to_simple</span></code></a>([v_prop, e_prop])</p></td>
<td><p>Project nx graph to a simple graph to run builtin alogorithms.</p></td>
</tr>
</tbody>
</table>
<div class="section" id="reading-graphs">
<h3>Reading graphs<a class="headerlink" href="#reading-graphs" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="edge-list">
<h2>Edge List<a class="headerlink" href="#edge-list" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="graphscope.experimental.nx.read_edgelist">
<code class="sig-prename descclassname">graphscope.experimental.nx.</code><code class="sig-name descname">read_edgelist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">comments</span><span class="o">=</span><span class="default_value">'#'</span></em>, <em class="sig-param"><span class="n">delimiter</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">create_using</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nodetype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">edgetype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">encoding</span><span class="o">=</span><span class="default_value">'utf-8'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/graphscope/experimental/nx/readwrite/edgelist.html#read_edgelist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graphscope.experimental.nx.read_edgelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a graph from a list of edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>file</em><em> or </em><em>string</em>) – File or filename to read. If a file is provided, it must be
opened in ‘rb’ mode.
Filenames ending in .gz or .bz2 will be uncompressed.</p></li>
<li><p><strong>comments</strong> (<em>string</em><em>, </em><em>optional</em>) – The character used to indicate the start of a comment.</p></li>
<li><p><strong>delimiter</strong> (<em>string</em><em>, </em><em>optional</em>) – The string used to separate values.  The default is whitespace.</p></li>
<li><p><strong>create_using</strong> (<em>NetworkX graph constructor</em><em>, </em><em>optional</em><em> (</em><em>default=nx.Graph</em><em>)</em>) – Graph type to create. If graph instance, then cleared before populated.</p></li>
<li><p><strong>nodetype</strong> (<em>int</em><em>, </em><em>float</em><em>, </em><em>str</em><em>, </em><em>Python type</em><em>, </em><em>optional</em>) – Convert node data from strings to specified type</p></li>
<li><p><strong>data</strong> (<em>bool</em><em> or </em><em>list of</em><em> (</em><em>label</em><em>,</em><em>type</em><em>) </em><em>tuples</em>) – Tuples specifying dictionary key names and types for edge data</p></li>
<li><p><strong>edgetype</strong> (<em>int</em><em>, </em><em>float</em><em>, </em><em>str</em><em>, </em><em>Python type</em><em>, </em><em>optional OBSOLETE</em>) – Convert edge data from strings to specified type and use as ‘weight’</p></li>
<li><p><strong>encoding</strong> (<em>string</em><em>, </em><em>optional</em>) – Specify which encoding to use when reading file.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – A networkx Graph or other type specified with create_using</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>graph</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">write_edgelist</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="s2">&quot;test.edgelist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_edgelist</span><span class="p">(</span><span class="s2">&quot;test.edgelist&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;test.edgelist&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_edgelist</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_edgelist</span><span class="p">(</span><span class="s2">&quot;test.edgelist&quot;</span><span class="p">,</span> <span class="n">nodetype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_edgelist</span><span class="p">(</span><span class="s2">&quot;test.edgelist&quot;</span><span class="p">,</span> <span class="n">create_using</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">)</span>
</pre></div>
</div>
<p>Edgelist with data in a list:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">textline</span> <span class="o">=</span> <span class="s2">&quot;1 2 3&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;test.edgelist&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">textline</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_edgelist</span><span class="p">(</span><span class="s2">&quot;test.edgelist&quot;</span><span class="p">,</span> <span class="n">nodetype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">[1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(1, 2, {&#39;weight&#39;: 3.0})]</span>
</pre></div>
</div>
<p>See parse_edgelist() for more examples of formatting.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">parse_edgelist</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">write_edgelist</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Since nodes must be hashable, the function nodetype must return hashable
types (e.g. int, float, str, frozenset - or tuples of those, etc.)</p>
</dd></dl>

</div>
<div class="section" id="adjacency-list">
<h2>Adjacency List<a class="headerlink" href="#adjacency-list" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="graphscope.experimental.nx.read_adjlist">
<code class="sig-prename descclassname">graphscope.experimental.nx.</code><code class="sig-name descname">read_adjlist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">comments</span><span class="o">=</span><span class="default_value">'#'</span></em>, <em class="sig-param"><span class="n">delimiter</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">create_using</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nodetype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">encoding</span><span class="o">=</span><span class="default_value">'utf-8'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/graphscope/experimental/nx/readwrite/adjlist.html#read_adjlist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graphscope.experimental.nx.read_adjlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Read graph in adjacency list format from path.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>string</em><em> or </em><em>file</em>) – Filename or file handle to read.
Filenames ending in .gz or .bz2 will be uncompressed.</p></li>
<li><p><strong>create_using</strong> (<em>NetworkX graph constructor</em><em>, </em><em>optional</em><em> (</em><em>default=nx.Graph</em><em>)</em>) – Graph type to create. If graph instance, then cleared before populated.</p></li>
<li><p><strong>nodetype</strong> (<em>Python type</em><em>, </em><em>optional</em>) – Convert nodes to this type.</p></li>
<li><p><strong>comments</strong> (<em>string</em><em>, </em><em>optional</em>) – Marker for comment lines</p></li>
<li><p><strong>delimiter</strong> (<em>string</em><em>, </em><em>optional</em>) – Separator for node labels.  The default is whitespace.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – The graph corresponding to the lines in adjacency list format.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NetworkX graph</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">write_adjlist</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;test.adjlist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_adjlist</span><span class="p">(</span><span class="s2">&quot;test.adjlist&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The path can be a filehandle or a string with the name of the file. If a
filehandle is provided, it has to be opened in ‘rb’ mode.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;test.adjlist&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_adjlist</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>
</pre></div>
</div>
<p>Filenames ending in .gz or .bz2 will be compressed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">write_adjlist</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;test.adjlist.gz&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_adjlist</span><span class="p">(</span><span class="s2">&quot;test.adjlist.gz&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The optional nodetype is a function to convert node strings to nodetype.</p>
<p>For example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_adjlist</span><span class="p">(</span><span class="s2">&quot;test.adjlist&quot;</span><span class="p">,</span> <span class="n">nodetype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<p>will attempt to convert all nodes to integer type.</p>
<p>Since nodes must be hashable, the function nodetype must return hashable
types (e.g. int, float, str, frozenset - or tuples of those, etc.)</p>
<p>The optional create_using parameter indicates the type of NetworkX graph
created.  The default is <cite>nx.Graph</cite>, an undirected graph.
To read the data as a directed graph use</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_adjlist</span><span class="p">(</span><span class="s2">&quot;test.adjlist&quot;</span><span class="p">,</span> <span class="n">create_using</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>This format does not store graph or node data.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_adjlist</span></code></p>
</div>
</dd></dl>

<div class="section" id="algorithms-on-mutable-graphs">
<h3>Algorithms on mutable graphs<a class="headerlink" href="#algorithms-on-mutable-graphs" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="graphscope.experimental.nx.Graph.project_to_simple">
<code class="sig-prename descclassname">graphscope.experimental.nx.Graph.</code><code class="sig-name descname">project_to_simple</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">v_prop</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">e_prop</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.Graph.project_to_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Project nx graph to a simple graph to run builtin alogorithms.</p>
<p>A simple graph is a accesser wrapper of property graph that only single edge
attribute and single node attribute are available.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v_prop</strong> (<em>the node attribute key to project</em><em>, </em><em>(</em><em>optional</em><em>, </em><em>default None</em><em>)</em>) – </p></li>
<li><p><strong>e_prop</strong> (<em>the edge attribute key to project</em><em>, </em><em>(</em><em>optional</em><em>, </em><em>default None</em><em>)</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>simple_graph</strong> – A nx.Graph object that hold a simple graph projected by host property graph.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#graphscope.experimental.nx.Graph" title="graphscope.experimental.nx.Graph">nx.Graph</a> or <a class="reference internal" href="#graphscope.experimental.nx.DiGraph" title="graphscope.experimental.nx.DiGraph">nx.DiGraph</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>the method is implicit called in builtin apps.</p>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.pagerank">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">pagerank</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.85</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-06</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.pagerank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the PageRank of the nodes in the graph.</p>
<p>PageRank computes a ranking of the nodes in the graph G based on
the structure of the incoming links. It was originally designed as
an algorithm to rank web pages.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>graph</em>) – A NetworkX graph.  Undirected graphs will be converted to a directed
graph with two directed edges for each undirected edge.</p></li>
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>optional</em>) – Damping parameter for PageRank, default=0.85.</p></li>
<li><p><strong>personalization</strong> (<em>dict</em><em>, </em><em>optional</em>) – The “personalization vector” consisting of a dictionary with a
key some subset of graph nodes and personalization value each of those.
At least one personalization value must be non-zero.
If not specfiied, a nodes personalization value will be zero.
By default, a uniform distribution is used.</p></li>
<li><p><strong>max_iter</strong> (<em>integer</em><em>, </em><em>optional</em>) – Maximum number of iterations in power method eigenvalue solver.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Error tolerance used to check convergence in power method solver.</p></li>
<li><p><strong>nstart</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – Starting value of PageRank iteration for each node.</p></li>
<li><p><strong>weight</strong> (<em>key</em><em>, </em><em>optional</em>) – Edge data key to use as weight.  If None weights are set to 1.</p></li>
<li><p><strong>dangling</strong> (<em>dict</em><em>, </em><em>optional</em>) – The outedges to be assigned to any “dangling” nodes, i.e., nodes without
any outedges. The dict key is the node the outedge points to and the dict
value is the weight of that outedge. By default, dangling nodes are given
outedges according to the personalization vector (uniform if not
specified). This must be selected to result in an irreducible transition
matrix (see notes under google_matrix). It may be common to have the
dangling dict to be the same as the personalization dict.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pagerank</strong> – Dictionary of nodes with PageRank as value</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pr</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The eigenvector calculation is done by the power iteration method
and has no guarantee of convergence.  The iteration will stop after
an error tolerance of <code class="docutils literal notranslate"><span class="pre">len(G)</span> <span class="pre">*</span> <span class="pre">tol</span></code> has been reached. If the
number of iterations exceed <cite>max_iter</cite>, a
<code class="xref py py-exc docutils literal notranslate"><span class="pre">networkx.exception.PowerIterationFailedConvergence</span></code> exception
is raised.</p>
<p>The PageRank algorithm was designed for directed graphs but this
algorithm does not check if the input graph is directed and will
execute on undirected graphs by converting each edge in the
directed graph to two edges.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pagerank_numpy</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">pagerank_scipy</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">google_matrix</span></code></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>PowerIterationFailedConvergence</strong> – If the algorithm fails to converge to the specified tolerance
    within the specified number of iterations of the power iteration
    method.</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id1"><span class="brackets">1</span></dt>
<dd><p>A. Langville and C. Meyer,
“A survey of eigenvector methods of web information retrieval.”
<a class="reference external" href="http://citeseer.ist.psu.edu/713792.html">http://citeseer.ist.psu.edu/713792.html</a></p>
</dd>
<dt class="label" id="id2"><span class="brackets">2</span></dt>
<dd><p>Page, Lawrence; Brin, Sergey; Motwani, Rajeev and Winograd, Terry,
The PageRank citation ranking: Bringing order to the Web. 1999
<a class="reference external" href="http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&amp;doc=1999-66&amp;format=pdf">http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&amp;doc=1999-66&amp;format=pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.hits">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">hits</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">normalized</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.hits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns HITS hubs and authorities values for nodes.</p>
<p>The HITS algorithm computes two numbers for a node.
Authorities estimates the node value based on the incoming links.
Hubs estimates the node value based on outgoing links.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>graph</em>) – A NetworkX graph</p></li>
<li><p><strong>max_iter</strong> (<em>integer</em><em>, </em><em>optional</em>) – Maximum number of iterations in power method.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Error tolerance used to check convergence in power method iteration.</p></li>
<li><p><strong>nstart</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – Starting value of each node for power method iteration.</p></li>
<li><p><strong>normalized</strong> (<em>bool</em><em> (</em><em>default=True</em><em>)</em>) – Normalize results by the sum of all of the values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>(hubs,authorities)</strong> – Two dictionaries keyed by node containing the hub and authority
values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>two-tuple of dictionaries</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>PowerIterationFailedConvergence</strong> – If the algorithm fails to converge to the specified tolerance
    within the specified number of iterations of the power iteration
    method.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">hits</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The eigenvector calculation is done by the power iteration method
and has no guarantee of convergence.  The iteration will stop
after max_iter iterations or an error tolerance of
number_of_nodes(G)*tol has been reached.</p>
<p>The HITS algorithm was designed for directed graphs but this
algorithm does not check if the input graph is directed and will
execute on undirected graphs.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets">1</span></dt>
<dd><p>A. Langville and C. Meyer,
“A survey of eigenvector methods of web information retrieval.”
<a class="reference external" href="http://citeseer.ist.psu.edu/713792.html">http://citeseer.ist.psu.edu/713792.html</a></p>
</dd>
<dt class="label" id="id4"><span class="brackets">2</span></dt>
<dd><p>Jon Kleinberg,
Authoritative sources in a hyperlinked environment
Journal of the ACM 46 (5): 604-32, 1999.
doi:10.1145/324133.324140.
http://www.cs.cornell.edu/home/kleinber/auth.pdf.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.degree_centrality">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">degree_centrality</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.degree_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the degree centrality for nodes.</p>
<p>The degree centrality for a node v is the fraction of nodes it
is connected to.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> (<em>graph</em>) – A networkx graph</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nodes</strong> – Dictionary of nodes with degree centrality as the value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">betweenness_centrality</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">load_centrality</span></code>, <a class="reference internal" href="#graphscope.experimental.nx.builtin.eigenvector_centrality" title="graphscope.experimental.nx.builtin.eigenvector_centrality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenvector_centrality</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The degree centrality values are normalized by dividing by the maximum
possible degree in a simple graph n-1 where n is the number of nodes in G.</p>
<p>For multigraphs or graphs with self loops the maximum degree might
be higher than n-1 and values of degree centrality greater than 1
are possible.</p>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.in_degree_centrality">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">in_degree_centrality</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.in_degree_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the in-degree centrality for nodes.</p>
<p>The in-degree centrality for a node v is the fraction of nodes its
incoming edges are connected to.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> (<em>graph</em>) – A NetworkX graph</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nodes</strong> – Dictionary of nodes with in-degree centrality as values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>NetworkXNotImplemented</strong> – If G is undirected.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#graphscope.experimental.nx.builtin.degree_centrality" title="graphscope.experimental.nx.builtin.degree_centrality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree_centrality</span></code></a>, <a class="reference internal" href="#graphscope.experimental.nx.builtin.out_degree_centrality" title="graphscope.experimental.nx.builtin.out_degree_centrality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_degree_centrality</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The degree centrality values are normalized by dividing by the maximum
possible degree in a simple graph n-1 where n is the number of nodes in G.</p>
<p>For multigraphs or graphs with self loops the maximum degree might
be higher than n-1 and values of degree centrality greater than 1
are possible.</p>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.out_degree_centrality">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">out_degree_centrality</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.out_degree_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the out-degree centrality for nodes.</p>
<p>The out-degree centrality for a node v is the fraction of nodes its
outgoing edges are connected to.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> (<em>graph</em>) – A NetworkX graph</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nodes</strong> – Dictionary of nodes with out-degree centrality as values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>NetworkXNotImplemented</strong> – If G is undirected.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#graphscope.experimental.nx.builtin.degree_centrality" title="graphscope.experimental.nx.builtin.degree_centrality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree_centrality</span></code></a>, <a class="reference internal" href="#graphscope.experimental.nx.builtin.in_degree_centrality" title="graphscope.experimental.nx.builtin.in_degree_centrality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_degree_centrality</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The degree centrality values are normalized by dividing by the maximum
possible degree in a simple graph n-1 where n is the number of nodes in G.</p>
<p>For multigraphs or graphs with self loops the maximum degree might
be higher than n-1 and values of degree centrality greater than 1
are possible.</p>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.eigenvector_centrality">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">eigenvector_centrality</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.eigenvector_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the eigenvector centrality for the graph <cite>G</cite>.</p>
<p>Eigenvector centrality computes the centrality for a node based on the
centrality of its neighbors. The eigenvector centrality for node $i$ is
the $i$-th element of the vector $x$ defined by the equation</p>
<div class="math notranslate nohighlight">
\[Ax = \lambda x\]</div>
<p>where $A$ is the adjacency matrix of the graph <cite>G</cite> with eigenvalue
$lambda$. By virtue of the Perron–Frobenius theorem, there is a unique
solution $x$, all of whose entries are positive, if $lambda$ is the
largest eigenvalue of the adjacency matrix $A$ (<a href="#id25"><span class="problematic" id="id5">[2]_</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>graph</em>) – A networkx graph</p></li>
<li><p><strong>max_iter</strong> (<em>integer</em><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – Maximum number of iterations in power method.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em><em> (</em><em>default=1.0e-6</em><em>)</em>) – Error tolerance used to check convergence in power method iteration.</p></li>
<li><p><strong>nstart</strong> (<em>dictionary</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Starting value of eigenvector iteration for each node.</p></li>
<li><p><strong>weight</strong> (<em>None</em><em> or </em><em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If None, all edge weights are considered equal.
Otherwise holds the name of the edge attribute used as weight.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nodes</strong> – Dictionary of nodes with eigenvector centrality as the value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centrality</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">eigenvector_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{c:0.2f}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">centrality</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(0, &#39;0.37&#39;), (1, &#39;0.60&#39;), (2, &#39;0.60&#39;), (3, &#39;0.37&#39;)]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>NetworkXPointlessConcept</strong> – If the graph <cite>G</cite> is the null graph.</p></li>
<li><p><strong>NetworkXError</strong> – If each value in <cite>nstart</cite> is zero.</p></li>
<li><p><strong>PowerIterationFailedConvergence</strong> – If the algorithm fails to converge to the specified tolerance
    within the specified number of iterations of the power iteration
    method.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenvector_centrality_numpy</span></code>, <a class="reference internal" href="#graphscope.experimental.nx.builtin.pagerank" title="graphscope.experimental.nx.builtin.pagerank"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pagerank</span></code></a>, <a class="reference internal" href="#graphscope.experimental.nx.builtin.hits" title="graphscope.experimental.nx.builtin.hits"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hits</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The measure was introduced by <a href="#id26"><span class="problematic" id="id6">[1]_</span></a> and is discussed in <a href="#id27"><span class="problematic" id="id7">[2]_</span></a>.</p>
<p>The power iteration method is used to compute the eigenvector and
convergence is <strong>not</strong> guaranteed. Our method stops after <code class="docutils literal notranslate"><span class="pre">max_iter</span></code>
iterations or when the change in the computed vector between two
iterations is smaller than an error tolerance of
<code class="docutils literal notranslate"><span class="pre">G.number_of_nodes()</span> <span class="pre">*</span> <span class="pre">tol</span></code>. This implementation uses ($A + I$)
rather than the adjacency matrix $A$ because it shifts the spectrum
to enable discerning the correct eigenvector even for networks with
multiple dominant eigenvalues.</p>
<p>For directed graphs this is “left” eigenvector centrality which corresponds
to the in-edges in the graph. For out-edges eigenvector centrality
first reverse the graph with <code class="docutils literal notranslate"><span class="pre">G.reverse()</span></code>.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets">1</span></dt>
<dd><p>Phillip Bonacich.
“Power and Centrality: A Family of Measures.”
<em>American Journal of Sociology</em> 92(5):1170–1182, 1986
&lt;<a class="reference external" href="http://www.leonidzhukov.net/hse/2014/socialnetworks/papers/Bonacich-Centrality.pdf">http://www.leonidzhukov.net/hse/2014/socialnetworks/papers/Bonacich-Centrality.pdf</a>&gt;</p>
</dd>
<dt class="label" id="id9"><span class="brackets">2</span></dt>
<dd><p>Mark E. J. Newman.
<em>Networks: An Introduction.</em>
Oxford University Press, USA, 2010, pp. 169.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.katz_centrality">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">katz_centrality</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">beta</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">nstart</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">normalized</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.katz_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Katz centrality for the nodes of the graph G.</p>
<p>Katz centrality computes the centrality for a node based on the centrality
of its neighbors. It is a generalization of the eigenvector centrality. The
Katz centrality for node $i$ is</p>
<div class="math notranslate nohighlight">
\[x_i = \alpha \sum_{j} A_{ij} x_j + \beta,\]</div>
<p>where $A$ is the adjacency matrix of graph G with eigenvalues $lambda$.</p>
<p>The parameter $beta$ controls the initial centrality and</p>
<div class="math notranslate nohighlight">
\[\alpha &lt; \frac{1}{\lambda_{\max}}.\]</div>
<p>Katz centrality computes the relative influence of a node within a
network by measuring the number of the immediate neighbors (first
degree nodes) and also all other nodes in the network that connect
to the node under consideration through these immediate neighbors.</p>
<p>Extra weight can be provided to immediate neighbors through the
parameter $beta$.  Connections made with distant neighbors
are, however, penalized by an attenuation factor $alpha$ which
should be strictly less than the inverse largest eigenvalue of the
adjacency matrix in order for the Katz centrality to be computed
correctly. More information is provided in <a href="#id28"><span class="problematic" id="id10">[1]_</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>graph</em>) – A NetworkX graph.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – Attenuation factor</p></li>
<li><p><strong>beta</strong> (<em>scalar</em><em> or </em><em>dictionary</em><em>, </em><em>optional</em><em> (</em><em>default=1.0</em><em>)</em>) – Weight attributed to the immediate neighborhood. If not a scalar, the
dictionary must have an value for every node.</p></li>
<li><p><strong>max_iter</strong> (<em>integer</em><em>, </em><em>optional</em><em> (</em><em>default=1000</em><em>)</em>) – Maximum number of iterations in power method.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em><em> (</em><em>default=1.0e-6</em><em>)</em>) – Error tolerance used to check convergence in power method iteration.</p></li>
<li><p><strong>nstart</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – Starting value of Katz iteration for each node.</p></li>
<li><p><strong>normalized</strong> (<em>bool</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True normalize the resulting values.</p></li>
<li><p><strong>weight</strong> (<em>None</em><em> or </em><em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If None, all edge weights are considered equal.
Otherwise holds the name of the edge attribute used as weight.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nodes</strong> – Dictionary of nodes with Katz centrality as the value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>NetworkXError</strong> – If the parameter <cite>beta</cite> is not a scalar but lacks a value for at least
    one node</p></li>
<li><p><strong>PowerIterationFailedConvergence</strong> – If the algorithm fails to converge to the specified tolerance
    within the specified number of iterations of the power iteration
    method.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.0</span>  <span class="c1"># largest eigenvalue of adj matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centrality</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">katz_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">phi</span> <span class="o">-</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">centrality</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{n}</span><span class="s2"> </span><span class="si">{c:.2f}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">0 0.37</span>
<span class="go">1 0.60</span>
<span class="go">2 0.60</span>
<span class="go">3 0.37</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">katz_centrality_numpy</span></code>, <a class="reference internal" href="#graphscope.experimental.nx.builtin.eigenvector_centrality" title="graphscope.experimental.nx.builtin.eigenvector_centrality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenvector_centrality</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenvector_centrality_numpy</span></code>, <a class="reference internal" href="#graphscope.experimental.nx.builtin.pagerank" title="graphscope.experimental.nx.builtin.pagerank"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pagerank</span></code></a>, <a class="reference internal" href="#graphscope.experimental.nx.builtin.hits" title="graphscope.experimental.nx.builtin.hits"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hits</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Katz centrality was introduced by <a href="#id29"><span class="problematic" id="id11">[2]_</span></a>.</p>
<p>This algorithm it uses the power method to find the eigenvector
corresponding to the largest eigenvalue of the adjacency matrix of <code class="docutils literal notranslate"><span class="pre">G</span></code>.
The parameter <code class="docutils literal notranslate"><span class="pre">alpha</span></code> should be strictly less than the inverse of largest
eigenvalue of the adjacency matrix for the algorithm to converge.
You can use <code class="docutils literal notranslate"><span class="pre">max(nx.adjacency_spectrum(G))</span></code> to get $lambda_{max}$ the largest
eigenvalue of the adjacency matrix.
The iteration will stop after <code class="docutils literal notranslate"><span class="pre">max_iter</span></code> iterations or an error tolerance of
<code class="docutils literal notranslate"><span class="pre">number_of_nodes(G)</span> <span class="pre">*</span> <span class="pre">tol</span></code> has been reached.</p>
<p>When $alpha = 1/lambda_{max}$ and $beta=0$, Katz centrality is the same
as eigenvector centrality.</p>
<p>For directed graphs this finds “left” eigenvectors which corresponds
to the in-edges in the graph. For out-edges Katz centrality
first reverse the graph with <code class="docutils literal notranslate"><span class="pre">G.reverse()</span></code>.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id12"><span class="brackets">1</span></dt>
<dd><p>Mark E. J. Newman:
Networks: An Introduction.
Oxford University Press, USA, 2010, p. 720.</p>
</dd>
<dt class="label" id="id13"><span class="brackets">2</span></dt>
<dd><p>Leo Katz:
A New Status Index Derived from Sociometric Index.
Psychometrika 18(1):39–43, 1953
<a class="reference external" href="http://phya.snu.ac.kr/~dkim/PRL87278701.pdf">http://phya.snu.ac.kr/~dkim/PRL87278701.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.has_path">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">has_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span></em>, <em class="sig-param"><span class="n">target</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.has_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <em>True</em> if <em>G</em> has a path from <em>source</em> to <em>target</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>NetworkX graph</em>) – </p></li>
<li><p><strong>source</strong> (<em>node</em>) – Starting node for path</p></li>
<li><p><strong>target</strong> (<em>node</em>) – Ending node for path</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.shortest_path">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">shortest_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.shortest_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute shortest paths in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>NetworkX graph</em>) – </p></li>
<li><p><strong>source</strong> (<em>node</em><em>, </em><em>optional</em>) – Starting node for path. If not specified, compute shortest
paths for each possible starting node.</p></li>
<li><p><strong>target</strong> (<em>node</em><em>, </em><em>optional</em>) – Ending node for path. If not specified, compute shortest
paths to all possible nodes.</p></li>
<li><p><strong>weight</strong> (<em>None</em><em> or </em><em>string</em><em>, </em><em>optional</em><em> (</em><em>default = None</em><em>)</em>) – If None, every edge has weight/distance/cost 1.
If a string, use this edge attribute as the edge weight.
Any edge attribute not present defaults to 1.</p></li>
<li><p><strong>method</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default = 'dijkstra'</em><em>)</em>) – The algorithm to use to compute the path.
Supported options: ‘dijkstra’, ‘bellman-ford’.
Other inputs produce a ValueError.
If <cite>weight</cite> is None, unweighted graph methods are used, and this
suggestion is ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>path</strong> – All returned paths include both the source and target in the path.</p>
<p>If the source and target are both specified, return a single list
of nodes in a shortest path from the source to the target.</p>
<p>If only the source is specified, return a dictionary keyed by
targets with a list of nodes in a shortest path from the source
to one of the targets.</p>
<p>If only the target is specified, return a dictionary keyed by
sources with a list of nodes in a shortest path from one of the
sources to the target.</p>
<p>If neither the source nor target are specified return a dictionary
of dictionaries with path[source][target]=[list of nodes in path].</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list or dictionary</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>NodeNotFound</strong> – If <cite>source</cite> is not in <cite>G</cite>.</p></li>
<li><p><strong>ValueError</strong> – If <cite>method</cite> is not among the supported options.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># target not specified</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># source not specified</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>  <span class="c1"># source, target not specified</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>There may be more than one shortest path between a source and target.
This returns only one of them.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_pairs_shortest_path</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">all_pairs_dijkstra_path</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">all_pairs_bellman_ford_path</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">single_source_shortest_path</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">single_source_dijkstra_path</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">single_source_bellman_ford_path</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.single_source_dijkstra_path_length">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">single_source_dijkstra_path_length</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.single_source_dijkstra_path_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Find shortest weighted path lengths in G from a source node.</p>
<p>Compute the shortest path length between source and all other
reachable nodes for a weighted graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>NetworkX graph</em>) – </p></li>
<li><p><strong>source</strong> (<em>node label</em>) – Starting node for path</p></li>
<li><p><strong>cutoff</strong> (<em>integer</em><em> or </em><em>float</em><em>, </em><em>optional</em>) – Depth to stop the search. Only return paths with length &lt;= cutoff.</p></li>
<li><p><strong>weight</strong> (<em>string</em><em> or </em><em>function</em>) – <p>If this is a string, then edge weights will be accessed via the
edge attribute with this key (that is, the weight of the edge
joining <cite>u</cite> to <cite>v</cite> will be <code class="docutils literal notranslate"><span class="pre">G.edges[u,</span> <span class="pre">v][weight]</span></code>). If no
such edge attribute exists, the weight of the edge is assumed to
be one.</p>
<p>If this is a function, the weight of an edge is the value
returned by the function. The function must accept exactly three
positional arguments: the two endpoints of an edge and the
dictionary of edge attributes for that edge. The function must
return a number.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>length</strong> – Dict keyed by node to shortest path length from source.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>NodeNotFound</strong> – If <cite>source</cite> is not in <cite>G</cite>.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">length</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">single_source_dijkstra_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">length</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{node}</span><span class="s2">: </span><span class="si">{length[node]}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">0: 0</span>
<span class="go">1: 1</span>
<span class="go">2: 2</span>
<span class="go">3: 3</span>
<span class="go">4: 4</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.</p>
<p>The weight function can be used to hide edges by returning None.
So <code class="docutils literal notranslate"><span class="pre">weight</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">u,</span> <span class="pre">v,</span> <span class="pre">d:</span> <span class="pre">1</span> <span class="pre">if</span> <span class="pre">d['color']==&quot;red&quot;</span> <span class="pre">else</span> <span class="pre">None</span></code>
will find the shortest red path.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">single_source_dijkstra</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">single_source_bellman_ford_path_length</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.average_shortest_path_length">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">average_shortest_path_length</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.average_shortest_path_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the average shortest path length.</p>
<p>The average shortest path length is</p>
<div class="math notranslate nohighlight">
\[a =\sum_{s,t \in V} \frac{d(s, t)}{n(n-1)}\]</div>
<p>where <cite>V</cite> is the set of nodes in <cite>G</cite>,
<cite>d(s, t)</cite> is the shortest path from <cite>s</cite> to <cite>t</cite>,
and <cite>n</cite> is the number of nodes in <cite>G</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>NetworkX graph</em>) – </p></li>
<li><p><strong>weight</strong> (<em>None</em><em> or </em><em>string</em><em>, </em><em>optional</em><em> (</em><em>default = None</em><em>)</em>) – If None, every edge has weight/distance/cost 1.
If a string, use this edge attribute as the edge weight.
Any edge attribute not present defaults to 1.</p></li>
<li><p><strong>method</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default = 'unweighted'</em><em> or </em><em>'djikstra'</em><em>)</em>) – The algorithm to use to compute the path lengths.
Supported options are ‘unweighted’, ‘dijkstra’, ‘bellman-ford’,
‘floyd-warshall’ and ‘floyd-warshall-numpy’.
Other method values produce a ValueError.
The default method is ‘unweighted’ if <cite>weight</cite> is None,
otherwise the default method is ‘dijkstra’.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>NetworkXPointlessConcept</strong> – If <cite>G</cite> is the null graph (that is, the graph on zero nodes).</p></li>
<li><p><strong>NetworkXError</strong> – If <cite>G</cite> is not connected (or not weakly connected, in the case
    of a directed graph).</p></li>
<li><p><strong>ValueError</strong> – If <cite>method</cite> is not among the supported options.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">average_shortest_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>For disconnected graphs, you can compute the average shortest path
length for each component</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">average_shortest_path_length</span><span class="p">(</span><span class="n">C</span><span class="p">))</span>
<span class="go">1.0</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.bfs_edges">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">bfs_edges</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span></em>, <em class="sig-param"><span class="n">reverse</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">depth_limit</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.bfs_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over edges in a breadth-first-search starting at source.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>NetworkX graph</em>) – </p></li>
<li><p><strong>source</strong> (<em>node</em>) – Specify starting node for breadth-first search; this function
iterates over only those edges in the component reachable from
this node.</p></li>
<li><p><strong>reverse</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True traverse a directed graph in the reverse direction</p></li>
<li><p><strong>depth_limit</strong> (<em>int</em><em>, </em><em>optional</em><em>(</em><em>default=len</em><em>(</em><em>G</em><em>)</em><em>)</em>) – Specify the maximum search depth</p></li>
<li><p><strong>sort_neighbors</strong> (<em>function</em>) – A function that takes the list of neighbors of given node as input, and
returns an <em>iterator</em> over these neighbors but with custom ordering.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>edges</strong> – A generator of edges in the breadth-first-search.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>generator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>To get the edges in a breadth-first search:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">[(0, 1), (1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">depth_limit</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(0, 1)]</span>
</pre></div>
</div>
<p>To get the nodes in a breadth-first search order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">bfs_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nodes</span>
<span class="go">[2, 1, 0]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The naming of this function is very similar to edge_bfs. The difference
is that ‘edge_bfs’ yields edges even if they extend back to an already
explored node while ‘bfs_edges’ yields the edges of the tree that results
from a breadth-first-search (BFS) so no edges are reported if they extend
to already explored nodes. That means ‘edge_bfs’ reports all edges while
‘bfs_edges’ only reports those traversed by a node-based BFS. Yet another
description is that ‘bfs_edges’ reports the edges traversed during BFS
while ‘edge_bfs’ reports all edges in the order they are explored.</p>
<p>Based on <a class="reference external" href="http://www.ics.uci.edu/~eppstein/PADS/BFS.py">http://www.ics.uci.edu/~eppstein/PADS/BFS.py</a>.
by D. Eppstein, July 2004. The modifications
to allow depth limits based on the Wikipedia article
“<a class="reference external" href="https://en.wikipedia.org/wiki/Depth-limited_search">Depth-limited-search</a>”.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bfs_tree</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">dfs_edges</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_bfs</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.bfs_predecessors">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">bfs_predecessors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span></em>, <em class="sig-param"><span class="n">depth_limit</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.bfs_predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator of predecessors in breadth-first-search from source.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>NetworkX graph</em>) – </p></li>
<li><p><strong>source</strong> (<em>node</em>) – Specify starting node for breadth-first search</p></li>
<li><p><strong>depth_limit</strong> (<em>int</em><em>, </em><em>optional</em><em>(</em><em>default=len</em><em>(</em><em>G</em><em>)</em><em>)</em>) – Specify the maximum search depth</p></li>
<li><p><strong>sort_neighbors</strong> (<em>function</em>) – A function that takes the list of neighbors of given node as input, and
returns an <em>iterator</em> over these neighbors but with custom ordering.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pred</strong> – (node, predecessors) iterator where predecessors is the list of
predecessors of the node.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>iterator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_predecessors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">{1: 0, 2: 1}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_predecessors</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">{1: 0, 2: 0, 3: 1, 4: 1, 5: 2, 6: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_predecessors</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">depth_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">)))</span>
<span class="go">[(0, 1), (2, 1), (3, 2), (4, 3), (7, 2), (8, 7)]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Based on <a class="reference external" href="http://www.ics.uci.edu/~eppstein/PADS/BFS.py">http://www.ics.uci.edu/~eppstein/PADS/BFS.py</a>
by D. Eppstein, July 2004. The modifications
to allow depth limits based on the Wikipedia article
“<a class="reference external" href="https://en.wikipedia.org/wiki/Depth-limited_search">Depth-limited-search</a>”.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bfs_tree</span></code>, <a class="reference internal" href="#graphscope.experimental.nx.builtin.bfs_edges" title="graphscope.experimental.nx.builtin.bfs_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bfs_edges</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_bfs</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.bfs_successors">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">bfs_successors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span></em>, <em class="sig-param"><span class="n">depth_limit</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.bfs_successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator of successors in breadth-first-search from source.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>NetworkX graph</em>) – </p></li>
<li><p><strong>source</strong> (<em>node</em>) – Specify starting node for breadth-first search</p></li>
<li><p><strong>depth_limit</strong> (<em>int</em><em>, </em><em>optional</em><em>(</em><em>default=len</em><em>(</em><em>G</em><em>)</em><em>)</em>) – Specify the maximum search depth</p></li>
<li><p><strong>sort_neighbors</strong> (<em>function</em>) – A function that takes the list of neighbors of given node as input, and
returns an <em>iterator</em> over these neighbors but with custom ordering.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>succ</strong> – (node, successors) iterator where successors is the list of
successors of the node.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>iterator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_successors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">{0: [1], 1: [2]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_successors</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">{0: [1, 2], 1: [3, 4], 2: [5, 6]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_successors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">depth_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">)))</span>
<span class="go">{1: [0, 2], 2: [3, 7], 3: [4], 7: [8]}</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Based on <a class="reference external" href="http://www.ics.uci.edu/~eppstein/PADS/BFS.py">http://www.ics.uci.edu/~eppstein/PADS/BFS.py</a>
by D. Eppstein, July 2004.The modifications
to allow depth limits based on the Wikipedia article
“<a class="reference external" href="https://en.wikipedia.org/wiki/Depth-limited_search">Depth-limited-search</a>”.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bfs_tree</span></code>, <a class="reference internal" href="#graphscope.experimental.nx.builtin.bfs_edges" title="graphscope.experimental.nx.builtin.bfs_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bfs_edges</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_bfs</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.k_core">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">k_core</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">k</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">core_number</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.k_core" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the k-core of G.</p>
<p>A k-core is a maximal subgraph that contains nodes of degree k or more.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>NetworkX graph</em>) – A graph or directed graph</p></li>
<li><p><strong>k</strong> (<em>int</em><em>, </em><em>optional</em>) – The order of the core.  If not specified return the main core.</p></li>
<li><p><strong>core_number</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – Precomputed core numbers for the graph G.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – The k-core subgraph</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NetworkX graph</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>NetworkXError</strong> – The k-core is not defined for graphs with self loops or parallel edges.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The main core is the core with the largest degree.</p>
<p>Not implemented for graphs with parallel edges or self loops.</p>
<p>For directed graphs the node degree is defined to be the
in-degree + out-degree.</p>
<p>Graph, node, and edge attributes are copied to the subgraph.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">core_number</span></code></p>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id16"><span class="brackets">1</span></dt>
<dd><p>An O(m) Algorithm for Cores Decomposition of Networks
Vladimir Batagelj and Matjaz Zaversnik,  2003.
<a class="reference external" href="https://arxiv.org/abs/cs.DS/0310049">https://arxiv.org/abs/cs.DS/0310049</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.clustering">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">clustering</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">nodes</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.clustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the clustering coefficient for nodes.</p>
<p>For unweighted graphs, the clustering of a node <span class="math notranslate nohighlight">\(u\)</span>
is the fraction of possible triangles through that node that exist,</p>
<div class="math notranslate nohighlight">
\[c_u = \frac{2 T(u)}{deg(u)(deg(u)-1)},\]</div>
<p>where <span class="math notranslate nohighlight">\(T(u)\)</span> is the number of triangles through node <span class="math notranslate nohighlight">\(u\)</span> and
<span class="math notranslate nohighlight">\(deg(u)\)</span> is the degree of <span class="math notranslate nohighlight">\(u\)</span>.</p>
<p>For weighted graphs, there are several ways to define clustering <a href="#id30"><span class="problematic" id="id17">[1]_</span></a>.
the one used here is defined
as the geometric average of the subgraph edge weights <a href="#id31"><span class="problematic" id="id18">[2]_</span></a>,</p>
<div class="math notranslate nohighlight">
\[c_u = \frac{1}{deg(u)(deg(u)-1))}
      \sum_{vw} (\hat{w}_{uv} \hat{w}_{uw} \hat{w}_{vw})^{1/3}.\]</div>
<p>The edge weights <span class="math notranslate nohighlight">\(\hat{w}_{uv}\)</span> are normalized by the maximum weight
in the network <span class="math notranslate nohighlight">\(\hat{w}_{uv} = w_{uv}/\max(w)\)</span>.</p>
<p>The value of <span class="math notranslate nohighlight">\(c_u\)</span> is assigned to 0 if <span class="math notranslate nohighlight">\(deg(u) &lt; 2\)</span>.</p>
<p>For directed graphs, the clustering is similarly defined as the fraction
of all possible directed triangles or geometric average of the subgraph
edge weights for unweighted and weighted directed graph respectively <a class="footnote-reference brackets" href="#id22" id="id19">3</a>.</p>
<div class="math notranslate nohighlight">
\[c_u = \frac{1}{deg^{tot}(u)(deg^{tot}(u)-1) - 2deg^{\leftrightarrow}(u)}
      T(u),\]</div>
<p>where <span class="math notranslate nohighlight">\(T(u)\)</span> is the number of directed triangles through node
<span class="math notranslate nohighlight">\(u\)</span>, <span class="math notranslate nohighlight">\(deg^{tot}(u)\)</span> is the sum of in degree and out degree of
<span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(deg^{\leftrightarrow}(u)\)</span> is the reciprocal degree of
<span class="math notranslate nohighlight">\(u\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>graph</em>) – </p></li>
<li><p><strong>nodes</strong> (<em>container of nodes</em><em>, </em><em>optional</em><em> (</em><em>default=all nodes in G</em><em>)</em>) – Compute clustering for nodes in this container.</p></li>
<li><p><strong>weight</strong> (<em>string</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The edge attribute that holds the numerical value used as a weight.
If None, then each edge has weight 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Clustering coefficient at specified nodes</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float, or dictionary</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">clustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">clustering</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
<span class="go">{0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0}</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Self loops are ignored.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id20"><span class="brackets">1</span></dt>
<dd><p>Generalizations of the clustering coefficient to weighted
complex networks by J. Saramäki, M. Kivelä, J.-P. Onnela,
K. Kaski, and J. Kertész, Physical Review E, 75 027105 (2007).
<a class="reference external" href="http://jponnela.com/web_documents/a9.pdf">http://jponnela.com/web_documents/a9.pdf</a></p>
</dd>
<dt class="label" id="id21"><span class="brackets">2</span></dt>
<dd><p>Intensity and coherence of motifs in weighted complex
networks by J. P. Onnela, J. Saramäki, J. Kertész, and K. Kaski,
Physical Review E, 71(6), 065103 (2005).</p>
</dd>
<dt class="label" id="id22"><span class="brackets"><a class="fn-backref" href="#id19">3</a></span></dt>
<dd><p>Clustering in complex directed networks by G. Fagiolo,
Physical Review E, 76(2), 026107 (2007).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.triangles">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">triangles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">nodes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the number of triangles.</p>
<p>Finds the number of triangles that include a node as one vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>graph</em>) – A networkx graph</p></li>
<li><p><strong>nodes</strong> (<em>container of nodes</em><em>, </em><em>optional</em><em> (</em><em>default= all nodes in G</em><em>)</em>) – Compute triangles for nodes in this container.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Number of triangles keyed by node label.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">triangles</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">triangles</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
<span class="go">{0: 6, 1: 6, 2: 6, 3: 6, 4: 6}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">triangles</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
<span class="go">[6, 6]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>When computing triangles for the entire graph each triangle is counted
three times, once at each node.  Self loops are ignored.</p>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.transitivity">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">transitivity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.transitivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute graph transitivity, the fraction of all possible triangles
present in G.</p>
<p>Possible triangles are identified by the number of “triads”
(two edges with a shared vertex).</p>
<p>The transitivity is</p>
<div class="math notranslate nohighlight">
\[T = 3\frac{\#triangles}{\#triads}.\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> (<em>graph</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Transitivity</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">transitivity</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.average_clustering">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">average_clustering</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">nodes</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">count_zeros</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.average_clustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the average clustering coefficient for the graph G.</p>
<p>The clustering coefficient for the graph is the average,</p>
<div class="math notranslate nohighlight">
\[C = \frac{1}{n}\sum_{v \in G} c_v,\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in <cite>G</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>graph</em>) – </p></li>
<li><p><strong>nodes</strong> (<em>container of nodes</em><em>, </em><em>optional</em><em> (</em><em>default=all nodes in G</em><em>)</em>) – Compute average clustering for nodes in this container.</p></li>
<li><p><strong>weight</strong> (<em>string</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The edge attribute that holds the numerical value used as a weight.
If None, then each edge has weight 1.</p></li>
<li><p><strong>count_zeros</strong> (<em>bool</em>) – If False include only the nodes with nonzero clustering in the average.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>avg</strong> – Average clustering</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">average_clustering</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>This is a space saving routine; it might be faster
to use the clustering function to get a list and then take the average.</p>
<p>Self loops are ignored.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id23"><span class="brackets">1</span></dt>
<dd><p>Generalizations of the clustering coefficient to weighted
complex networks by J. Saramäki, M. Kivelä, J.-P. Onnela,
K. Kaski, and J. Kertész, Physical Review E, 75 027105 (2007).
<a class="reference external" href="http://jponnela.com/web_documents/a9.pdf">http://jponnela.com/web_documents/a9.pdf</a></p>
</dd>
<dt class="label" id="id24"><span class="brackets">2</span></dt>
<dd><p>Marcus Kaiser,  Mean clustering coefficients: the role of isolated
nodes and leafs on clustering measures for small-world networks.
<a class="reference external" href="https://arxiv.org/abs/0802.2512">https://arxiv.org/abs/0802.2512</a></p>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="generated/graphscope.experimental.nx.Graph.__init__.html" class="btn btn-neutral float-right" title="graphscope.experimental.nx.Graph.__init__" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="NetworkX-style API(Preview)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020-2023, Damo Academy, Alibaba Inc.

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>