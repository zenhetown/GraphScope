

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>GraphScope Analytical Engine &mdash; GraphScope  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="GraphScope Learning Engine" href="learning_engine.html" />
    <link rel="prev" title="GraphScope Interactive Engine" href="interactive_engine.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> GraphScope
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="deployment.html">Deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="loading_graph.html">Loading Graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="interactive_engine.html">GraphScope Interactive Engine</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">GraphScope Analytical Engine</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#built-in-algorithms">Built-in Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#result-processing">Result Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#writing-your-own-algorithms-in-pie">Writing Your Own Algorithms in PIE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#writing-algorithms-in-pregel">Writing Algorithms in Pregel</a></li>
<li class="toctree-l2"><a class="reference internal" href="#run-your-own-algorithms">Run Your Own Algorithms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="learning_engine.html">GraphScope Learning Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="developer_guide.html">Developer Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="reference/python_index.html">Python API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference/analytical_engine_index.html">Analytical Engine API Reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GraphScope</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>GraphScope Analytical Engine</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/analytics_engine.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="graphscope-analytical-engine">
<h1>GraphScope Analytical Engine<a class="headerlink" href="#graphscope-analytical-engine" title="Permalink to this headline">¶</a></h1>
<p>The analytical engine in GraphScope derives from
<a class="reference external" href="https://dl.acm.org/doi/10.1145/3282488">GRAPE</a>,
a graph processing system proposed on SIGMOD-2017.
GRAPE differs from prior systems in its ability
to parallelize sequential graph algorithms as a whole. In GRAPE,
sequential algorithms can be easily “plugged into”
with only minor changes and get parallelized to handle large graphs efficiently.
In addition to the ease of programming, GRAPE is designed to be
highly efficient and flexible, to cope the scale,
variety and complexity from real-life graph applications.</p>
<div class="section" id="built-in-algorithms">
<h2>Built-in Algorithms<a class="headerlink" href="#built-in-algorithms" title="Permalink to this headline">¶</a></h2>
<p>GraphScope analytical engine provides many common used algorithms,
including connectivity and path
analysis, community detection, centrality computations.</p>
<p>Built-in algorithms can be easily invoked over loaded graphs. For example,</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span>from graphscope import pagerank
from graphscope import lpa

# algorithms defined on property graph can be invoked directly.
result = lpa(g)

# some other algorithms may only support evaluate on simple graph
# hence we need to generate one by selecting a kind of vertices and edges.
simple_g = g.project_to_simple(v_label=&quot;users&quot;, e_label=&quot;follows&quot;)
result_pr = pagerank(simple_g)
</pre></div>
</div>
<p>A full-list of builtin algorithms is shown as below. Whether an algorithm supports
property graph or not is described in its docstring.</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
</tbody>
</table>
<ul class="simple">
<li><p><a class="reference internal" href="reference/app.html#graphscope.bfs" title="graphscope.bfs"><code class="xref py py-func docutils literal notranslate"><span class="pre">bfs()</span></code></a></p></li>
<li><p><a class="reference internal" href="reference/app.html#graphscope.cdlp" title="graphscope.cdlp"><code class="xref py py-func docutils literal notranslate"><span class="pre">cdlp()</span></code></a></p></li>
<li><p><a class="reference internal" href="reference/app.html#graphscope.clustering" title="graphscope.clustering"><code class="xref py py-func docutils literal notranslate"><span class="pre">clustering()</span></code></a></p></li>
<li><p><a class="reference internal" href="reference/app.html#graphscope.degree_centrality" title="graphscope.degree_centrality"><code class="xref py py-func docutils literal notranslate"><span class="pre">degree_centrality()</span></code></a></p></li>
<li><p><a class="reference internal" href="reference/app.html#graphscope.eigenvector_centrality" title="graphscope.eigenvector_centrality"><code class="xref py py-func docutils literal notranslate"><span class="pre">eigenvector_centrality()</span></code></a></p></li>
<li><p><a class="reference internal" href="reference/app.html#graphscope.hits" title="graphscope.hits"><code class="xref py py-func docutils literal notranslate"><span class="pre">hits()</span></code></a></p></li>
<li><p><a class="reference internal" href="reference/app.html#graphscope.k_core" title="graphscope.k_core"><code class="xref py py-func docutils literal notranslate"><span class="pre">k_core()</span></code></a></p></li>
<li><p><a class="reference internal" href="reference/app.html#graphscope.katz_centrality" title="graphscope.katz_centrality"><code class="xref py py-func docutils literal notranslate"><span class="pre">katz_centrality()</span></code></a></p></li>
<li><p><a class="reference internal" href="reference/app.html#graphscope.lpa" title="graphscope.lpa"><code class="xref py py-func docutils literal notranslate"><span class="pre">lpa()</span></code></a></p></li>
<li><p><a class="reference internal" href="reference/app.html#graphscope.pagerank" title="graphscope.pagerank"><code class="xref py py-func docutils literal notranslate"><span class="pre">pagerank()</span></code></a></p></li>
<li><p><a class="reference internal" href="reference/app.html#graphscope.sssp" title="graphscope.sssp"><code class="xref py py-func docutils literal notranslate"><span class="pre">sssp()</span></code></a></p></li>
<li><p><a class="reference internal" href="reference/app.html#graphscope.triangles" title="graphscope.triangles"><code class="xref py py-func docutils literal notranslate"><span class="pre">triangles()</span></code></a></p></li>
<li><p><a class="reference internal" href="reference/app.html#graphscope.wcc" title="graphscope.wcc"><code class="xref py py-func docutils literal notranslate"><span class="pre">wcc()</span></code></a></p></li>
</ul>
<p>The list is continuously growing.</p>
</div>
<div class="section" id="result-processing">
<h2>Result Processing<a class="headerlink" href="#result-processing" title="Permalink to this headline">¶</a></h2>
<p>When finish a computation, the results are wrapped as <a class="reference internal" href="reference/context.html#context"><span class="std std-ref">Context</span></a>
and preserved on the distributed machines.</p>
<p>Users may want to fetch the results to the client, or write to cloud or distributed file systems.</p>
<p>There is a list of supported method to retrieve the results.</p>
<div class="highlight-iPython notranslate"><div class="highlight"><pre><span></span># fetch to data structures
result_pr.to_numpy()
result_pr.to_dataframe()

# or write to hdfs or oss, or local (local to pod)
result_pr.output(&quot;hdfs://output&quot;)
result_pr.output(&quot;oss://id:key@endpoint/bucket/object&quot;)
result_pr.output(&quot;file:///tmp/path&quot;)

# or write to client local
result_pr.output_to_client(&quot;local_filename&quot;)

# or seal to vineyard
result_pr.to_vineyard_dataframe()
result_pr.to_vineyard_numpy()
</pre></div>
</div>
<p>In addition, as shown in the Getting_Started, computation results can add back to
the graph as a new property (column) of the vertices(edges).</p>
<div class="highlight-iPython notranslate"><div class="highlight"><pre><span></span>simple_g = sub_graph.project_to_simple(vlabel=&quot;paper&quot;, elabel=&quot;cites&quot;)
ret = graphscope.kcore(simple_g, k=5)

# add the results as new columns to the citation graph
subgraph = sub_graph.add_column(ret, {&#39;kcore&#39;: &#39;r&#39;})
</pre></div>
</div>
<p>Users may assign a <a class="reference internal" href="reference/selector.html#selector"><span class="std std-ref">Selector</span></a> to define which parts of the results to write. A selector specifies
which part of the result to preserve. Similarly, the graph data can
also be a part of the result, e.g., the vertex id. We reserve three keywords for selectors.
<cite>r</cite> represents the result, <cite>v</cite> and <cite>e</cite> for vertices and edges, respectively.
Here are some examples for selectors on result processing.</p>
<div class="highlight-iPython notranslate"><div class="highlight"><pre><span></span># get the results on the vertex
result_pr.to_numpy(&#39;r&#39;)

# to dataframe,
# using the `id` of vertices (`v.id`) as a column named df_v
# using the `data` of v (`v.data`) as a column named df_vd
# and using the result (`r`) as a column named df_result
result_pr.to_dataframe({&#39;df_v&#39;: &#39;v.id&#39;, &#39;df_vd&#39;: &#39;v.data&#39;, &#39;df_result&#39;: &#39;r&#39;})

# for results on property graph
# using `:` as a label selector for v and e
# using the id for vertices labeled with label0 (`v:label0.id`) as column `id`
# using the property0 written on vertices with label0 as column `result`
result.output(fd=&#39;hdfs:///gs_data/output&#39;, \
        selector={&#39;id&#39;: &#39;v:label0.id&#39;, &#39;result&#39;: &#39;r:label0.property0&#39;})
</pre></div>
</div>
<p>See more details in <a class="reference internal" href="reference/context.html#context"><span class="std std-ref">Context</span></a> and <a class="reference internal" href="reference/selector.html#selector"><span class="std std-ref">Selector</span></a>.</p>
</div>
<div class="section" id="writing-your-own-algorithms-in-pie">
<h2>Writing Your Own Algorithms in PIE<a class="headerlink" href="#writing-your-own-algorithms-in-pie" title="Permalink to this headline">¶</a></h2>
<p>Users may write their own algorithms if the built-in algorithms
do not meet their needs. <cite>graphscope</cite> enables users to write
algorithms in the <a class="reference external" href="https://dl.acm.org/doi/10.1145/3282488">PIE</a>
programming model in a pure Python mode.</p>
<a class="reference internal image-reference" href="_images/pie.png"><img alt="Workflow of PIE" class="align-center" src="_images/pie.png" style="width: 600px;" /></a>
<p>To implement this, a user just need to fulfill this class.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span>@graphscope.analytical.udf.pie
class YourAlgorithm(AppAssets):
    @staticmethod
    def Initialize(context, frag):
        pass

    @staticmethod
    def PEval(context, frag):
        pass

    @staticmethod
    def IncEval(context, frag):
        pass
</pre></div>
</div>
<p>As shown in the code, users need to implement a class decorated with
<cite>&#64;graphscope.analytical.udf.pie</cite> and provides three sequential graph functions.
In the class, the <cite>Initialize</cite> is a function to set the initial status. <cite>PEval</cite> is
a sequential method for partial evaluation, and <cite>IncEval</cite> is a sequential function
for incremental evaluation over the partitioned fragment. The full API of fragment
can be found in <a class="reference internal" href="reference/cython_sdk.html#cython-sdk-api"><span class="std std-ref">Cython SDK API</span></a>.</p>
<p>Let’s take SSSP as example, a user defined SSSP in PIE model may be like this.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span>@graphscope.analytical.udf.pie
class SSSP:
    @staticmethod
    def Initialize(context, frag):
        v_label_num = frag.vertex_label_num()
        # init every vertex with a max distance representing unreachable.
        for v_label_id in range(v_label_num):
            nodes = frag.nodes(v_label_id)
            context.init_value(nodes, v_label_id, 1000000000.0,
                           PIEAggregateType.kMinAggregate)
        context.register_sync_buffer(MessageStrategy.kSyncOnOuterVertex)

    @staticmethod
    def PEval(context, frag):
        # get the source node from the query, passed from context.
        src = int(context.get_config(b&#39;src&#39;))
        graphscope.declare(graphscope.Vertex, source)
        native_source = False
        v_label_num = frag.vertex_label_num()
        for v_label_id in range(v_label_num):
            if frag.get_inner_node(v_label_id, src, source):
                native_source = True
                break
        if native_source:
            context.set_node_value(source, 0)
        else:
            return

        # in the source fragment, run the dijkstra algorithm as partial evaluation.
        e_label_num = frag.edge_label_num()
        for e_label_id in range(e_label_num):
            edges = frag.get_outgoing_edges(source, e_label_id)
            for e in edges:
                dst = e.neighbor()
                distv = e.get_int(2)
                if context.get_node_value(dst) &gt; distv:
                    context.set_node_value(dst, distv)

    @staticmethod
    def IncEval(context, frag):
        v_label_num = frag.vertex_label_num()
        e_label_num = frag.edge_label_num()
        # incremental computation to update the distance.
        for v_label_id in range(v_label_num):
            iv = frag.inner_nodes(v_label_id)
            for v in iv:
                v_dist = context.get_node_value(v)
                for e_label_id in range(e_label_num):
                    es = frag.get_outgoing_edges(v, e_label_id)
                    for e in es:
                        u = e.neighbor()
                        u_dist = v_dist + e.get_int(2)
                        if context.get_node_value(u) &gt; u_dist:
                            context.set_node_value(u, u_dist)
</pre></div>
</div>
<p>As shown in the code, users only need to design and implement sequential algorithm
over a fragment, rather than considering the communication and message passing
in the distributed setting. In this case, the classic dijkstra algorithm and its
incremental version works for large graphs partitioned on a cluster.</p>
</div>
<div class="section" id="writing-algorithms-in-pregel">
<h2>Writing Algorithms in Pregel<a class="headerlink" href="#writing-algorithms-in-pregel" title="Permalink to this headline">¶</a></h2>
<p>In addition to the sub-graph based PIE model,
<cite>graphscope</cite> supports vertex-centric
<cite>Pregel</cite> model as well.
You may develop an algorithms in <cite>Pregel</cite> model by implementing this.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span>@pregel(vd_type=&#39;double&#39;, md_type=&#39;double&#39;)
class YourPregelAlgorithm(AppAssets):

    @staticmethod
    def Init(v, context):
        pass

    @staticmethod
    def Compute(messages, v, context):
        pass

    @staticmethod
    def Combine(messages):
        pass
</pre></div>
</div>
<p>Differ from the PIE model, the decorator for this class is &#64;graphscope.analytical.udf.pregel.
And the functions to be implemented is defined on vertex, rather than the fragment.
Take SSSP as example, the algorithm in Pregel model looks like this.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span># decorator, and assign the types for vertex data, message data.
@pregel(vd_type=&#39;double&#39;, md_type=&#39;double&#39;)
class SSSP_Pregel(AppAssets):

    @staticmethod
    def Init(v, context):
        v.set_value(1000000000.0)

    @staticmethod
    def Compute(messages, v, context):
        src_id = context.get_config(b&quot;src&quot;)
        cur_dist = v.value()
        new_dist = 1000000000.0
        if v.id() == src_id:
            new_dist = 0
        for message in messages:
            new_dist = min(message, new_dist)
        if new_dist &lt; cur_dist:
            v.set_value(new_dist)
            for e_label_id in range(context.edge_label_num()):
                edges = v.outgoing_edges(e_label_id)
                for e in edges:
                    v.send(e.vertex(), new_dist + e.get_int(2))
        v.vote_to_halt()

    @staticmethod
    def Combine(messages):
        ret = 1000000000.0
        for m in messages:
            ret = min(ret, m)
        return ret
</pre></div>
</div>
</div>
<div class="section" id="run-your-own-algorithms">
<h2>Run Your Own Algorithms<a class="headerlink" href="#run-your-own-algorithms" title="Permalink to this headline">¶</a></h2>
<p>To run your own algorithms, you may trigger it in place where you defined it.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span>import graphscope

sess = graphscope.session()
g = sess.load_from(&quot;...&quot;)

# load my algorithm
my_app = SSSP_Pregel()

# run my algorithm over a graph and get the result.
ret = my_app(g, source=&quot;0&quot;)
</pre></div>
</div>
<p>After developing and testing, you may want to save it for the future use.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span>SSSP_Pregel.to_gar(&quot;file:///var/graphscope/udf/my_sssp_pregel.gar&quot;)
</pre></div>
</div>
<p>Later, you can load your own algorithm from the gar package.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span>import graphscope

sess = graphscope.session()
g = sess.load_from(&quot;...&quot;)

# load my algorithm from a gar package
my_app = load_app(&#39;SSSP_Pregel&#39;, &#39;file:///var/graphscope/udf/my_sssp_pregel.gar&#39;)

# run my algorithm over a graph and get the result.
ret = my_app(g, src=&quot;0&quot;)
</pre></div>
</div>
<p><strong>Publications</strong></p>
<ul class="simple">
<li><p>Wenfei Fan, Jingbo Xu, Wenyuan Yu, Jingren Zhou, Xiaojian Luo, Ping Lu, Qiang Yin, Yang Cao, and Ruiqi Xu. <a class="reference external" href="https://dl.acm.org/doi/10.1145/3282488">Parallelizing Sequential Graph Computations.</a>, ACM Transactions on Database Systems (TODS) 43(4): 18:1-18:39.</p></li>
<li><p>Wenfei Fan, Jingbo Xu, Yinghui Wu, Wenyuan Yu, Jiaxin Jiang. <a class="reference external" href="http://www.vldb.org/pvldb/vol10/p1889-fan.pdf">GRAPE: Parallelizing Sequential Graph Computations.</a>, The 43rd International Conference on Very Large Data Bases (VLDB), demo, 2017 (the Best Demo Award).</p></li>
<li><p>Wenfei Fan, Jingbo Xu, Yinghui Wu, Wenyuan Yu, Jiaxin Jiang, Zeyu Zheng, Bohan Zhang, Yang Cao, and Chao Tian. <a class="reference external" href="https://dl.acm.org/doi/10.1145/3035918.3035942">Parallelizing Sequential Graph Computations.</a>, ACM SIG Conference on Management of Data (SIGMOD), 2017 (the Best Paper Award).</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="learning_engine.html" class="btn btn-neutral float-right" title="GraphScope Learning Engine" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="interactive_engine.html" class="btn btn-neutral float-left" title="GraphScope Interactive Engine" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020-2023, Damo Academy, Alibaba Inc.

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>